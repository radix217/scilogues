<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Ontology Graph</title>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/elkjs/lib/elk.bundled.js"></script>
    <script src="https://unpkg.com/cytoscape-elk@2.2.0/cytoscape-elk.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div id="tree-container" style="width:100%; height:100vh;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function () {
            if (window.cytoscapeElk) {
                cytoscape.use(window.cytoscapeElk);
            }

            const container = document.getElementById('tree-container');
            const cy = cytoscape({
                container,
                elements: [],
                style: [
                    { selector: 'node', style: { 'label': 'data(label)', 'background-opacity': 0, 'border-width': 0, 'color': 'data(color)', 'text-valign': 'center', 'text-halign': 'center', 'font-size': '12px', 'text-outline-width': 2, 'text-outline-color': '#1f242d' } },
                    { selector: 'edge', style: { 'curve-style': 'bezier', 'target-arrow-shape': 'triangle', 'target-arrow-color': '#7f8fa6', 'line-color': '#7f8fa6', 'width': 1.5 } },
                    { selector: 'node.highlight', style: { 'color': '#00e5ff', 'text-outline-color': '#101318', 'text-outline-width': 3 } }
                ],
                wheelSensitivity: 0.2,
            });

            const socket = io();

            function colorForDepth(depth) {
                const d = typeof depth === 'number' ? depth : 0;
                const minHue = 120;
                const maxHue = 270;
                const span = maxHue - minHue;
                const period = 8;
                const t = (d % period) / (period - 1);
                const hue = Math.round(minHue + span * t);
                return `hsl(${hue}, 65%, 45%)`;
            }

            // Run ELK layout
            function runLayout(animated = true) {
                const layout = cy.layout({
                    name: 'elk',
                    nodeDimensionsIncludeLabels: true,
                    animate: animated,
                    animationDuration: 600,
                    animationEasing: 'ease-in-out',
                    fit: true,
                    padding: 30,
                    elk: {
                        algorithm: 'layered',
                        'elk.direction': 'DOWN',
                        'elk.layered.spacing.nodeNodeBetweenLayers': 80,
                        'elk.spacing.nodeNode': 40,
                        'elk.spacing.edgeNode': 20,
                        'elk.layered.nodePlacement.strategy': 'NETWORK_SIMPLEX',
                        'elk.edgeRouting': 'POLYLINE',
                        'elk.layered.crossingMinimization.semiInteractive': true,
                        'elk.initialPositions': false
                    }
                });
                layout.run();
            }

            // Buffer nodes and edges for batch layout
            let nodesBuffer = [];
            let edgesBuffer = [];
            let layoutScheduled = false;

            function scheduleBufferedLayout() {
                if (layoutScheduled) return;
                layoutScheduled = true;
                setTimeout(() => {
                    cy.batch(() => {
                        if (nodesBuffer.length > 0) cy.add(nodesBuffer);
                        if (edgesBuffer.length > 0) cy.add(edgesBuffer);
                    });
                    nodesBuffer = [];
                    edgesBuffer = [];
                    if (cy.elements().length > 0) runLayout(false);
                    layoutScheduled = false;
                }, 50);
            }

            // Existing nodes and edges
            socket.on('existing_nodes', (existingNodes) => {
                const toAdd = existingNodes.map(n => ({ data: { id: n.id, label: n.topic, color: colorForDepth(n.depth) } }));
                nodesBuffer.push(...toAdd);
                scheduleBufferedLayout();
            });

            socket.on('existing_edges', (existingEdges) => {
                const toAdd = existingEdges.map(e => ({ data: { id: `${e.parentid}-${e.childid}`, source: e.parentid, target: e.childid } }));
                edgesBuffer.push(...toAdd);
                scheduleBufferedLayout();
            });

            // New nodes
            socket.on('new_node', (node) => {
                const el = cy.getElementById(node.id);
                if (el && el.nonempty()) {
                    el.data('label', node.topic);
                    el.data('color', colorForDepth(node.depth));
                } else {
                    cy.batch(() => {
                        cy.add({ data: { id: node.id, label: node.topic, color: colorForDepth(node.depth) } });
                    });
                }
                if (node.parentid) {
                    const eid = `${node.parentid}-${node.id}`;
                    if (!cy.getElementById(eid).nonempty()) {
                        cy.batch(() => {
                            cy.add({ data: { id: eid, source: node.parentid, target: node.id } });
                        });
                    }
                }
                cy.$(`#${node.id}`).addClass('highlight');
                setTimeout(() => cy.$(`#${node.id}`).removeClass('highlight'), 600);
                scheduleLayout(true, 100);
            });

            // New edges
            socket.on('new_edge', (edge) => {
                if (edge && edge.from && edge.to) {
                    const eid = `${edge.from}-${edge.to}`;
                    if (!cy.getElementById(eid).nonempty()) {
                        cy.batch(() => {
                            cy.add({ data: { id: eid, source: edge.from, target: edge.to } });
                        });
                        scheduleLayout(true, 100);
                    }
                }
            });

            // Update nodes
            socket.on('update_node', (node) => {
                const el = cy.getElementById(node.id);
                if (el && el.nonempty()) {
                    el.addClass('highlight');
                    cy.animate({ center: { eles: el }, zoom: Math.min(2, Math.max(cy.zoom(), 1.2)) }, { duration: 500, easing: 'ease-in-out' });
                    setTimeout(() => el.removeClass('highlight'), 600);
                }
            });

            // Schedule re-layout
            let layoutTimer = null;
            function scheduleLayout(animated = true, delay = 200) {
                if (layoutTimer) clearTimeout(layoutTimer);
                layoutTimer = setTimeout(() => runLayout(animated), delay);
            }

            window.addEventListener('resize', () => {
                if (cy && cy.elements().length > 0) {
                    cy.fit(undefined, 30);
                }
            });

            // Optional periodic re-layout
            setInterval(() => {
                if (cy && cy.elements().length > 0) scheduleLayout(false, 0);
            }, 5000);
        });
    </script>
</body>
</html>
